/******************************************************************************
 * Top contributors (to current version):
 *   Alan Prado, Haniel Barbosa
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2024 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * Implementation of pseudo-boolean blasting functions for various operators.
 */

#include "cvc5_private.h"

#ifndef CVC5__THEORY__BV__PB__PB_BLAST_STRATEGIES_TEMPLATE_H
#define CVC5__THEORY__BV__PB__PB_BLAST_STRATEGIES_TEMPLATE_H

#include <cmath>
#include <ostream>
#include <sstream>
#include <string>

#include "theory/bv/pb/pb_blast_utils.h"
#include "theory/bv/theory_bv_utils.h"
#include "util/bitvector.h"

namespace cvc5::internal {
namespace theory {
namespace bv {
namespace pb {

/**
 * Default Atom PB-Bitblasting strategies: 
 * 
 * @param node the atom to be bitblasted
 * @param pbb the pseudo-boolean bitblaster
 */

template <class T, class U>
std::vector<U> UndefinedAtomPbStrategy(TNode node,
                                       TPseudoBooleanBlaster<T,U>* pbb)
{
  Trace("bv-pb") << "Undefined PB-blasting strategy for atom of kind: "
                 << node.getKind() << "\n";
  Unreachable(); 
}

template <class T, class U>
std::vector<U> DefaultEqPb(TNode node, TPseudoBooleanBlaster<T,U>* pbb)
{
  // TO-DO: consider adding bit-level equalities?
  Assert(node.getKind() == Kind::EQUAL);
  Trace("bv-pb") << "theory::bv::pb::DefaultEqPb " << node  << "\n";

  TSubproblem<T, U> lhs, rhs; 
  pbb->blastTerm(node[0], lhs);
  pbb->blastTerm(node[1], rhs);
  Assert(lhs.first.size() == rhs.first.size());

  std::ostringstream constraint;
  constraint << bvToUnsigned(lhs.first)
             << bvToUnsigned(rhs.first, -1)
             << "= 0 ;\n";
  Trace("bv-pb") << "theory::bv::pb::DefaultEqPb result " << constraint.str();

  std::vector<U> ret;
  ret.push_back(constraint.str());
  for (std::string c : lhs.second) { ret.push_back(c); }
  for (std::string c : rhs.second) { ret.push_back(c); }
  return ret;
}

template <class T, class U>
std::vector<U> DefaultUltPb(TNode node, TPseudoBooleanBlaster<T,U>* pbb) {
  Trace("bv-pb") << "theory::bv::pb::DefaultUltPb " << node  << "\n";
  Assert(node.getKind() == Kind::BITVECTOR_ULT);

  TSubproblem<T, U> lhs, rhs; 
  pbb->blastTerm(node[0], lhs);
  pbb->blastTerm(node[1], rhs);
  Assert(lhs.first.size() == rhs.first.size());

  std::ostringstream constraint;
  constraint << bvToUnsigned(rhs.first)
             << bvToUnsigned(lhs.first, -1)
             << ">= 1 ;\n";
  Trace("bv-pb") << "theory::bv::pb::DefaultUltPb result " << constraint.str();

  std::vector<U> ret;
  ret.push_back(constraint.str());
  for (std::string c : lhs.second) { ret.push_back(c); }
  for (std::string c : rhs.second) { ret.push_back(c); }
  return ret;
}

/**
 * Negated Atom PB-Bitblasting strategies: 
 * 
 * @param node the atom to be bitblasted
 * @param pbb the pseudo-boolean bitblaster
 */

template <class T, class U>
std::vector<U> NegatedEqPb(TNode node, TPseudoBooleanBlaster<T,U>* pbb)
{
  Assert(node.getKind() == Kind::EQUAL);
  Trace("bv-pb") << "theory::bv::pb::NegatedEqPb " << node  << "\n";

  Node xor_node = NodeManager::currentNM()->mkNode(Kind::BITVECTOR_XOR,
                                                   node[0], node[1]);
  TSubproblem<T, U> xor_sp; 
  pbb->blastTerm(xor_node, xor_sp);
  Assert(xor_sp.first.size() == utils::getSize(xor_node));

  std::ostringstream constraint;
  constraint << bvToClause(xor_sp.first);
  Trace("bv-pb") << "theory::bv::pb::NegatedEqPb result " << constraint.str();

  std::vector<U> ret;
  ret.push_back(constraint.str());
  for (std::string c : xor_sp.second) { ret.push_back(c); }
  return ret;
}

/* 
 * Default Term PB-Blasting strategies
 * 
 * @param node the term to be bitblasted
 * @param sp [output parameter] pair representing the variables and constraints
 *                              generated by the blasting process
 * @param pbb the bitblaster in which the clauses are added
 */

template <class T, class U>
void UndefinedTermPbStrategy(TNode node, TSubproblem<T,U>& sp,
                             TPseudoBooleanBlaster<T,U>* pbb)
{
  Trace("bv-pb") << "Undefined PB-blasting strategy for term of kind: "
                 << node.getKind() << "\n";
  Unreachable(); 
}

template <class T, class U>
void DefaultVarPb (TNode node, TSubproblem<T,U>& sp,
                   TPseudoBooleanBlaster<T,U>* pbb) {
  Trace("bv-pb") << "theory::bv::pb::DefaultVarPb blasting " << node;
  Assert(sp.first.size() == 0);
  pbb->makeVariables(node, sp);
  Trace("bv-pb") << " with bits " << toString(sp.first) << "\n"; 
}

template <class T, class U>
void DefaultConstPb (TNode node, TSubproblem<T,U>& sp,
                     TPseudoBooleanBlaster<T,U>* pbb) {
  Trace("bv-pb") << "theory::bv::pb::DefaultConstPb blasting " << node;
  Assert(node.getKind() == Kind::CONST_BITVECTOR);
  /** Are the following assertions necessary? */
  Assert(sp.first.size() == 0);
  Assert(sp.second.size() == 0);

  unsigned size = utils::getSize(node);
  for (unsigned i = 0; i < size; ++i) {
    Integer bit = node.getConst<BitVector>().extract(size-i-1, size-i-1)
                                            .getValue();
    sp.first.push_back(pbb->newVariable());
    std::ostringstream constraint;
    if(bit == Integer(0)){
      constraint << mkPbVar(sp.first[i]) << " = 0 ;\n";
    } else {
      Assert(bit == Integer(1));
      constraint << mkPbVar(sp.first[i]) << " = 1 ;\n";
    }
    sp.second.push_back(constraint.str());
  }

  Trace("bv-pb") << "with bits " << toString(sp.first) << "\n"; 
}

template <class T, class U>
void DefaultXorPb (TNode node, TSubproblem<T, U>& sp,
                   TPseudoBooleanBlaster<T, U>* pbb)
{
  Trace("bv-pb") << "theory::bv::pb::DefaultXorPb blasting " << node << "\n";
  Assert(node.getKind() == Kind::BITVECTOR_XOR && sp.first.size() == 0);
  if (node.getNumChildren() != 2) { Unreachable(); }

  TSubproblem<T, U> lhs, rhs; 
  pbb->blastTerm(node[0], lhs);
  pbb->blastTerm(node[1], rhs);
  pbb->makeVariables(node, sp);
  Assert(lhs.first.size() == rhs.first.size() &&
         rhs.first.size() == sp.first.size());

  for (unsigned i = 0; i < utils::getSize(node); i++)
  {
    for (std::string s : mkPbXor(lhs.first[i], rhs.first[i], sp.first[i]))
    {
      sp.second.push_back(s);
    }
  }

  for (std::string c : lhs.second) { sp.second.push_back(c); }
  for (std::string c : rhs.second) { sp.second.push_back(c); }
}

template <class T, class U>
void DefaultAddPb(TNode node, TSubproblem<T,U>& sp,
                  TPseudoBooleanBlaster<T,U>* pbb)
{
  Trace("bv-pb") << "theory::bv::pb::DefaultAddPb blasting " << node << "\n";
  Assert(node.getKind() == Kind::BITVECTOR_ADD && sp.first.size() == 0);

  std::ostringstream adder_constraint;
  for(unsigned i = 0; i < node.getNumChildren(); i++)
  {
    TSubproblem<T,U> aux;
    pbb->blastTerm(node[i], aux);
    for (std::string s : aux.second)
    {
      sp.second.push_back(s);
    }
    adder_constraint << bvToUnsigned(aux.first);
  }

  int extra_bits = ceil_log2(node.getNumChildren());
  std::vector<T> with_overflow;
  for (unsigned i = 0; i < utils::getSize(node) + extra_bits; i++)
  {
    with_overflow.push_back(pbb->newVariable());
  }
  adder_constraint << bvToUnsigned(with_overflow, -1);
  for (unsigned i = 0; i < utils::getSize(node); i++)
  {
    sp.first.push_back(with_overflow[extra_bits + i]);
  }
  adder_constraint << "= 0 ;\n";
  sp.second.push_back(adder_constraint.str());

  Assert(sp.first.size() == utils::getSize(node));
  Trace("bv-pb") << "theory::bv::pb::DefaultAddPb result "
                 << adder_constraint.str();
}

}  // namespace pb
}  // namespace bv
}  // namespace theory
}  // namespace cvc5::internal

#endif   // CVC5__THEORY__BV__PB__PB_BLAST_STRATEGIES_TEMPLATE_H
