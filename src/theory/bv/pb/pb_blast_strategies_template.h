/******************************************************************************
 * Top contributors (to current version):
 *   Alan Prado, Haniel Barbosa
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2024 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * Implementation of pseudo-boolean blasting functions for various operators.
 */

#include <algorithm>
#include <unordered_set>
#include "cvc5_private.h"

#ifndef CVC5__THEORY__BV__PB__PB_BLAST_STRATEGIES_TEMPLATE_H
#define CVC5__THEORY__BV__PB__PB_BLAST_STRATEGIES_TEMPLATE_H

#include <cmath>
#include <ostream>
#include <sstream>
#include <string>

#include "theory/bv/pb/pb_blast_utils.h"
#include "theory/bv/theory_bv_utils.h"
#include "util/bitvector.h"

namespace cvc5::internal {
namespace theory {
namespace bv {
namespace pb {

/**
 * Default Atom PB-Bitblasting strategies: 
 * 
 * @param node the atom to be bitblasted
 * @param pbb the pseudo-boolean bitblaster
 */

template <class T>
T UndefinedAtomPbStrategy(T atom, TPseudoBooleanBlaster<T>* pbb)
{
  Trace("bv-pb") << "Undefined PB-blasting strategy for atom of kind: "
                 << atom.getKind() << "\n";
  return pbb->ZERO;  // Remove this
  // Unreachable(); // TO-DO: remove comment
}

template <class T>
T DefaultEqPb(T atom, TPseudoBooleanBlaster<T>* pbb)
{
  // TO-DO: consider adding bit-level equalities?
  Assert(atom.getKind() == Kind::EQUAL);
  Trace("bv-pb") << "theory::bv::pb::DefaultEqPb " << atom << "\n";

  T lhs = pbb->blastTerm(atom[0]);
  Trace("bv-pb") << "LHS: " << atom[0] << "\n";
  Trace("bv-pb") << "RESULT: " << lhs << "\n";
  T rhs = pbb->blastTerm(atom[1]);
  Trace("bv-pb") << "RHS: " << atom[0] << "\n";
  Trace("bv-pb") << "RESULT: " << rhs << "\n";
//  Assert(lhs.first.size() == rhs.first.size());
//
//  std::ostringstream constraint;
//  constraint << bvToUnsigned(lhs.first)
//             << bvToUnsigned(rhs.first, -1)
//             << "= 0 ;\n";
//  Trace("bv-pb") << "theory::bv::pb::DefaultEqPb result " << constraint.str();
//
//  std::vector<U> ret;
//  ret.push_back(constraint.str());
//  for (std::string c : lhs.second) { ret.push_back(c); }
//  for (std::string c : rhs.second) { ret.push_back(c); }
//  return ret;
  return pbb->getNodeManager()->mkConstInt(Rational(0));  // Remove this
}

//template <class T, class U>
//std::vector<U> DefaultUltPb(TNode node, TPseudoBooleanBlaster<T,U>* pbb) {
//  Trace("bv-pb") << "theory::bv::pb::DefaultUltPb " << node  << "\n";
//  Assert(node.getKind() == Kind::BITVECTOR_ULT);
//
//  TSubproblem<T, U> lhs, rhs; 
//  pbb->blastTerm(node[0], lhs);
//  pbb->blastTerm(node[1], rhs);
//  Assert(lhs.first.size() == rhs.first.size());
//
//  std::ostringstream constraint;
//  constraint << bvToUnsigned(rhs.first)
//             << bvToUnsigned(lhs.first, -1)
//             << ">= 1 ;\n";
//  Trace("bv-pb") << "theory::bv::pb::DefaultUltPb result " << constraint.str();
//
//  std::vector<U> ret;
//  ret.push_back(constraint.str());
//  for (std::string c : lhs.second) { ret.push_back(c); }
//  for (std::string c : rhs.second) { ret.push_back(c); }
//  return ret;
//}
//
///**
// * Negated Atom PB-Bitblasting strategies: 
// * 
// * @param node the atom to be bitblasted
// * @param pbb the pseudo-boolean bitblaster
// */
//
//template <class T, class U>
//std::vector<U> NegatedEqPb(TNode node, TPseudoBooleanBlaster<T,U>* pbb)
//{
//  Assert(node.getKind() == Kind::EQUAL);
//  Trace("bv-pb") << "theory::bv::pb::NegatedEqPb " << node  << "\n";
//
//  Node xor_node = pbb->getNodeManager()->mkNode(Kind::BITVECTOR_XOR, node[0], node[1]);
//  TSubproblem<T, U> xor_sp; 
//  pbb->blastTerm(xor_node, xor_sp);
//  Assert(xor_sp.first.size() == utils::getSize(xor_node));
//
//  std::ostringstream constraint;
//  constraint << bvToClause(xor_sp.first);
//  Trace("bv-pb") << "theory::bv::pb::NegatedEqPb result " << constraint.str();
//
//  std::vector<U> ret;
//  ret.push_back(constraint.str());
//  for (std::string c : xor_sp.second) { ret.push_back(c); }
//  return ret;
//}

/* 
 * Default Term PB-Blasting strategies
 * 
 * @param node the term to be bitblasted
 * @param sp [output parameter] pair representing the variables and constraints
 *                              generated by the blasting process
 * @param pbb the bitblaster in which the clauses are added
 */

template <class T>
T UndefinedTermPbStrategy(T node, TPseudoBooleanBlaster<T>* pbb)
{
  Trace("bv-pb") << "Undefined PB-blasting strategy for term of kind: "
                 << node.getKind() << "\n";
  return pbb->ZERO;  // Remove this
  // Unreachable(); // Remove comment!!
}

template <class T>
T DefaultVarPb(T term, TPseudoBooleanBlaster<T>* pbb)
{
  Trace("bv-pb") << "theory::bv::pb::DefaultVarPb blasting " << term;
  Node variables = pbb->newVariable(utils::getSize(term));
  Trace("bv-pb") << " with bits " << variables << "\n";
  return mkTermNode(variables, std::vector<T>(), pbb->getNodeManager());
}

template <class T>
T DefaultConstPb(Node term, TPseudoBooleanBlaster<T>* pbb)
{
  Trace("bv-pb") << "theory::bv::pb::DefaultConstPb blasting " << term << "\n";
  Assert(term.getKind() == Kind::CONST_BITVECTOR);

  NodeManager* nm = pbb->getNodeManager();
  unsigned size = utils::getSize(term);
  Node variables = pbb->newVariable(size);


  std::vector<T> constraints;
  for (unsigned i = 0; i < size; i++)
  {
    Integer bit_value = term.getConst<BitVector>().extract(size-i-1, size-i-1)
                                                  .getValue();
    T rhs = bit_value == Integer(0) ? pbb->ZERO : pbb->ONE;
    constraints.push_back(mkConstraintNode(Kind::EQUAL, {variables[i]},
                                           {pbb->ONE}, rhs, nm));
  }

  Trace("bv-pb") << "with bits " << variables << "\n"; 
  return mkTermNode(variables, constraints, nm);
}

//template <class T, class U>
//void DefaultXorPb(TNode node, TSubproblem<T, U>& sp,
//                  TPseudoBooleanBlaster<T, U>* pbb)
//{
//  Trace("bv-pb") << "theory::bv::pb::DefaultXorPb blasting " << node << "\n";
//  Assert(node.getKind() == Kind::BITVECTOR_XOR && sp.first.size() == 0);
//  if (node.getNumChildren() != 2) { Unreachable(); }
//
//  TSubproblem<T, U> lhs, rhs; 
//  pbb->blastTerm(node[0], lhs);
//  pbb->blastTerm(node[1], rhs);
//  pbb->makeVariables(node, sp);
//  Assert(lhs.first.size() == rhs.first.size() &&
//         rhs.first.size() == sp.first.size());
//
//  for (unsigned i = 0; i < utils::getSize(node); i++)
//  {
//    for (std::string s : mkPbXor(lhs.first[i], rhs.first[i], sp.first[i]))
//    {
//      sp.second.push_back(s);
//    }
//  }
//
//  for (std::string c : lhs.second) { sp.second.push_back(c); }
//  for (std::string c : rhs.second) { sp.second.push_back(c); }
//}

template <class T>
T DefaultAddPb(T term, TPseudoBooleanBlaster<T>* pbb)
{
  Trace("bv-pb") << "theory::bv::pb::DefaultAddPb blasting " << term << "\n";
  Assert(term.getKind() == Kind::BITVECTOR_ADD);

  NodeManager* nm = pbb->getNodeManager();
  unsigned num_bits = utils::getSize(term);

  std::vector<Node> variables, coefficients;
  std::unordered_set<Node> constraints;

  std::vector<Node> aux = bvToUnsigned(num_bits, nm);
  for(unsigned i = 0; i < term.getNumChildren(); i++)
  {
    Node blasted = pbb->blastTerm(term[i]);
    Assert(blasted[0].getNumChildren() == num_bits);
    for (Node v: blasted[0]) { variables.push_back(v); }
    std::copy(aux.begin(), aux.end(), std::back_inserter(coefficients));
    for (Node c: blasted[1]) { constraints.insert(c); }
  }

  Trace("bv-pb") << variables << "\n";
  Trace("bv-pb") << coefficients << "\n";

  /** extra_bits used to store possible overflow */
  int extra_bits = ceil_log2(term.getNumChildren());
  T extra_vars = pbb->newVariable(extra_bits);
  for (T v : extra_vars) { variables.push_back(v); }

  T result_vars = pbb->newVariable(num_bits);
  for (T v : result_vars) { variables.push_back(v); }

  aux = bvToUnsigned(num_bits + extra_bits, nm, -1);
  std::move(aux.begin(), aux.end(), std::back_inserter(coefficients));

  constraints.insert(mkConstraintNode(Kind::EQUAL, variables, coefficients,
                                     pbb->ZERO, nm));

  T blasted_term = mkTermNode(result_vars, constraints, nm);

  Assert(blasted_term[0].getNumChildren() == utils::getSize(term));
  Trace("bv-pb") << "theory::bv::pb::DefaultAddPb result " << blasted_term << "\n";
  return blasted_term;
}

}  // namespace pb
}  // namespace bv
}  // namespace theory
}  // namespace cvc5::internal

#endif   // CVC5__THEORY__BV__PB__PB_BLAST_STRATEGIES_TEMPLATE_H
