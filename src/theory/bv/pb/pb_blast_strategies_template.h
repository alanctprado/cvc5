/******************************************************************************
 * Top contributors (to current version):
 *   Alan Prado, Haniel Barbosa
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2024 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * Implementation of pseudo-boolean blasting functions for various operators.
 */

#include <algorithm>
#include "cvc5_private.h"

#ifndef CVC5__THEORY__BV__PB__PB_BLAST_STRATEGIES_TEMPLATE_H
#define CVC5__THEORY__BV__PB__PB_BLAST_STRATEGIES_TEMPLATE_H

#include <cmath>
#include <ostream>
#include <sstream>
#include <string>

#include "theory/bv/pb/pb_blast_utils.h"
#include "theory/bv/theory_bv_utils.h"
#include "util/bitvector.h"

namespace cvc5::internal {
namespace theory {
namespace bv {
namespace pb {

/**
 * Default Atom PB-Bitblasting strategies: 
 * 
 * @param node the atom to be bitblasted
 * @param pbb the pseudo-boolean bitblaster
 */

template <class T, class U>
std::vector<U> UndefinedAtomPbStrategy(TNode node,
                                       TPseudoBooleanBlaster<T,U>* pbb)
{
  Trace("bv-pb") << "Undefined PB-blasting strategy for atom of kind: "
                 << node.getKind() << "\n";
  Unreachable(); 
}

template <class T, class U>
std::vector<U> DefaultEqPb(TNode node, TPseudoBooleanBlaster<T,U>* pbb)
{
  // TO-DO: consider adding bit-level equalities?
  Assert(node.getKind() == Kind::EQUAL);
  Trace("bv-pb") << "theory::bv::pb::DefaultEqPb " << node  << "\n";

  TSubproblem<T, U> lhs, rhs; 
  pbb->blastTerm(node[0], lhs);
  pbb->blastTerm(node[1], rhs);
  // OPaaaa
  lhs = rhs;
  Assert(lhs.first.size() == rhs.first.size());

  std::ostringstream constraint;
  constraint << bvToUnsigned(lhs.first)
             << bvToUnsigned(rhs.first, -1)
             << "= 0 ;\n";
  Trace("bv-pb") << "theory::bv::pb::DefaultEqPb result " << constraint.str();

  std::vector<U> ret;
  ret.push_back(constraint.str());
  for (std::string c : lhs.second) { ret.push_back(c); }
  for (std::string c : rhs.second) { ret.push_back(c); }
  return ret;
}

template <class T, class U>
std::vector<U> DefaultUltPb(TNode node, TPseudoBooleanBlaster<T,U>* pbb) {
  Trace("bv-pb") << "theory::bv::pb::DefaultUltPb " << node  << "\n";
  Assert(node.getKind() == Kind::BITVECTOR_ULT);

  TSubproblem<T, U> lhs, rhs; 
  pbb->blastTerm(node[0], lhs);
  pbb->blastTerm(node[1], rhs);
  Assert(lhs.first.size() == rhs.first.size());

  std::ostringstream constraint;
  constraint << bvToUnsigned(rhs.first)
             << bvToUnsigned(lhs.first, -1)
             << ">= 1 ;\n";
  Trace("bv-pb") << "theory::bv::pb::DefaultUltPb result " << constraint.str();

  std::vector<U> ret;
  ret.push_back(constraint.str());
  for (std::string c : lhs.second) { ret.push_back(c); }
  for (std::string c : rhs.second) { ret.push_back(c); }
  return ret;
}

/**
 * Negated Atom PB-Bitblasting strategies: 
 * 
 * @param node the atom to be bitblasted
 * @param pbb the pseudo-boolean bitblaster
 */

template <class T, class U>
std::vector<U> NegatedEqPb(TNode node, TPseudoBooleanBlaster<T,U>* pbb)
{
  Assert(node.getKind() == Kind::EQUAL);
  Trace("bv-pb") << "theory::bv::pb::NegatedEqPb " << node  << "\n";

  Node xor_node = pbb->getNodeManager()->mkNode(Kind::BITVECTOR_XOR, node[0], node[1]);
  TSubproblem<T, U> xor_sp; 
  pbb->blastTerm(xor_node, xor_sp);
  Assert(xor_sp.first.size() == utils::getSize(xor_node));

  std::ostringstream constraint;
  constraint << bvToClause(xor_sp.first);
  Trace("bv-pb") << "theory::bv::pb::NegatedEqPb result " << constraint.str();

  std::vector<U> ret;
  ret.push_back(constraint.str());
  for (std::string c : xor_sp.second) { ret.push_back(c); }
  return ret;
}

/* 
 * Default Term PB-Blasting strategies
 * 
 * @param node the term to be bitblasted
 * @param sp [output parameter] pair representing the variables and constraints
 *                              generated by the blasting process
 * @param pbb the bitblaster in which the clauses are added
 */

template <class T, class U>
void UndefinedTermPbStrategy(TNode node, TSubproblem<T,U>& sp,
                             TPseudoBooleanBlaster<T,U>* pbb)
{
  Trace("bv-pb") << "Undefined PB-blasting strategy for term of kind: "
                 << node.getKind() << "\n";
  Unreachable(); 
}

template <class T, class U>
void DefaultVarPb(TNode node, TSubproblem<T,U>& sp,
                  TPseudoBooleanBlaster<T,U>* pbb) {
  Trace("bv-pb") << "theory::bv::pb::DefaultVarPb blasting " << node;
  Assert(sp.first.size() == 0);
  pbb->makeVariables(node, sp);
  Trace("bv-pb") << " with bits " << toString(sp.first) << "\n"; 
}

template <class T, class U>
void DefaultConstPb(TNode node, TSubproblem<T,U>& sp,
                    TPseudoBooleanBlaster<T,U>* pbb) {
  Trace("bv-pb") << "theory::bv::pb::DefaultConstPb blasting " << node;
  Assert(node.getKind() == Kind::CONST_BITVECTOR);
  /** Are the following assertions necessary? */
  Assert(sp.first.size() == 0);
  Assert(sp.second.size() == 0);

  unsigned size = utils::getSize(node);
  for (unsigned i = 0; i < size; ++i) {
    Integer bit = node.getConst<BitVector>().extract(size-i-1, size-i-1)
                                            .getValue();
    sp.first.push_back(pbb->newVariable());
    pbb->newVariable2();
    std::ostringstream constraint;
    if(bit == Integer(0)){
      constraint << mkPbVar(sp.first[i]) << " = 0 ;\n";
    } else {
      Assert(bit == Integer(1));
      constraint << mkPbVar(sp.first[i]) << " = 1 ;\n";
    }
    sp.second.push_back(constraint.str());
  }

  Trace("bv-pb") << "with bits " << toString(sp.first) << "\n"; 
}

template <class T, class U>
void DefaultXorPb(TNode node, TSubproblem<T, U>& sp,
                  TPseudoBooleanBlaster<T, U>* pbb)
{
  Trace("bv-pb") << "theory::bv::pb::DefaultXorPb blasting " << node << "\n";
  Assert(node.getKind() == Kind::BITVECTOR_XOR && sp.first.size() == 0);
  if (node.getNumChildren() != 2) { Unreachable(); }

  TSubproblem<T, U> lhs, rhs; 
  pbb->blastTerm(node[0], lhs);
  pbb->blastTerm(node[1], rhs);
  pbb->makeVariables(node, sp);
  Assert(lhs.first.size() == rhs.first.size() &&
         rhs.first.size() == sp.first.size());

  for (unsigned i = 0; i < utils::getSize(node); i++)
  {
    for (std::string s : mkPbXor(lhs.first[i], rhs.first[i], sp.first[i]))
    {
      sp.second.push_back(s);
    }
  }

  for (std::string c : lhs.second) { sp.second.push_back(c); }
  for (std::string c : rhs.second) { sp.second.push_back(c); }
}

template <class T, class U>
void DefaultAddPb(TNode node, TSubproblem<T, U>& sp, TPseudoBooleanBlaster<T,U>* pbb)
{
  Trace("bv-pb") << "theory::bv::pb::DefaultAddPb blasting " << node << "\n";
  Assert(node.getKind() == Kind::BITVECTOR_ADD);

  NodeManager* nm = pbb->getNodeManager();

  std::vector<Node> children, constr_vars, constr_coeffs;

  std::vector<Node> mock_indexes;
  for (unsigned j = 0; j < 4; j++) mock_indexes.push_back(nm->mkConstInt(Rational(j)));
  Node mock_vars = nm->mkNode(Kind::SEXPR, mock_indexes);
  std::vector<Node> mock_coeffs = bvToUnsigned2(4, nm);
  Node mock_constraint = mkConstraintNode(mock_indexes, mock_coeffs, pbb->PB_EQ,
                                          pbb->ZERO, nm);
  Node mock_children = nm->mkNode(Kind::SEXPR, {mock_constraint, mock_constraint});
  for(unsigned i = 0; i < node.getNumChildren(); i++)
  {
    /** blasted = (( vars ), (children)) */
    // Node blasted = pbb->blastTerm(node[i]);
    Node blasted = nm->mkNode(Kind::SEXPR, {mock_vars, mock_children});
    for (Node c : blasted[1]) { children.push_back(c); }
    for (Node v : blasted[0]) { constr_vars.push_back(v); }
    std::vector<Node> c = bvToUnsigned2(blasted[0].getNumChildren(),
                                        nm);
    std::move(c.begin(), c.end(), std::back_inserter(constr_coeffs));
  }


  /** extra_bits used to store possible overflow */
  int extra_bits = ceil_log2(node.getNumChildren());
  unsigned res_bits = utils::getSize(node) + extra_bits;

  std::vector<Node> res_v(res_bits);
  std::vector<Node> flattened_vars(utils::getSize(node));
  std::generate(res_v.begin(), res_v.end(), [pbb] {
      return pbb->newVariable2(); });
  std::copy(res_v.begin() + extra_bits, res_v.end(), flattened_vars.begin());
  std::move(res_v.begin(), res_v.end(), std::back_inserter(constr_vars));

  std::vector<Node> res_c = bvToUnsigned2(res_bits, nm, -1);
  std::move(res_c.begin(), res_c.end(), std::back_inserter(constr_coeffs));

  Node constraint = mkConstraintNode(constr_vars, constr_coeffs, pbb->PB_EQ,
                                     pbb->ZERO, nm);

  std::vector<Node> blasted_children {constraint};
  blasted_children.push_back(children[0]); // Change to move children

  Node blasted_term = mkTermNode(flattened_vars, blasted_children, nm);

  Assert(blasted_term[0].getNumChildren() == utils::getSize(node));
  Trace("bv-pb") << "theory::bv::pb::DefaultAddPb result " << blasted_term << "\n";
}

}  // namespace pb
}  // namespace bv
}  // namespace theory
}  // namespace cvc5::internal

#endif   // CVC5__THEORY__BV__PB__PB_BLAST_STRATEGIES_TEMPLATE_H
